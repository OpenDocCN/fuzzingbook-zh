# 语法覆盖率

> 原文： [https://www.fuzzingbook.org/html/GrammarCoverageFuzzer.html](https://www.fuzzingbook.org/html/GrammarCoverageFuzzer.html)

[从语法](GrammarFuzzer.html)中产生输入时，规则的所有可能扩展都具有相同的可能性。 然而，对于产生一个全面的测试套件，使*品种*最大化是更有意义的-例如，不要一遍又一遍地重复相同的扩展。 在本章中，我们探索如何系统地*覆盖语法的*元素，以使我们最大限度地提高多样性并且不会漏掉单个元素。

**前提条件**

*   您应该阅读语法的[一章。](Grammars.html)
*   您应该已经阅读[关于有效语法模糊](GrammarFuzzer.html)的章节。

## 内容提要

要使用本章中提供的代码来[，请编写](Importing.html)

```py
>>> from [fuzzingbook.GrammarCoverageFuzzer](GrammarCoverageFuzzer.html) import <identifier>

```

然后利用以下功能。

本章介绍`GrammarCoverageFuzzer`，这是一种有效的语法模糊器，它是从[这一章中对有效语法模糊](GrammarFuzzer.html)进行扩展的。 它努力至少覆盖一次所有扩展。 例如，在下面的示例中，区号中的所有数字都不同，行号中的数字也都不同：

```py
>>> from [Grammars](Grammars.html) import US_PHONE_GRAMMAR
>>> phone_fuzzer = GrammarCoverageFuzzer(US_PHONE_GRAMMAR)
>>> phone_fuzzer.fuzz()
'(521)383-0695'

```

模糊处理后，`expansion_coverage()`方法返回所涵盖的语法扩展的映射。

```py
>>> phone_fuzzer.expansion_coverage()
{'<area> -> <lead-digit><digit><digit>',
 '<digit> -> 0',
 '<digit> -> 1',
 '<digit> -> 2',
 '<digit> -> 3',
 '<digit> -> 5',
 '<digit> -> 6',
 '<digit> -> 8',
 '<digit> -> 9',
 '<exchange> -> <lead-digit><digit><digit>',
 '<lead-digit> -> 3',
 '<lead-digit> -> 5',
 '<line> -> <digit><digit><digit><digit>',
 '<phone-number> -> (<area>)<exchange>-<line>',
 '<start> -> <phone-number>'}

```

随后对`fuzz()`的呼叫将进一步覆盖（例如，覆盖其他区号）。 重新调用`reset()`会清除记录的覆盖范围。

由于输入中的此类覆盖范围还会产生更高的代码覆盖范围，因此`GrammarCoverageFuzzer`是`GrammarFuzzer`的推荐扩展。

## 覆盖语法元素

测试生成的目的是涵盖程序的所有功能-当然希望包括失败的功能。 但是，此功能与输入的结构相关：如果我们无法生成某些输入元素，则也不会触发相关的代码和功能，从而减少了在其中查找错误的机会。

例如，请考虑语法[一章中的表达语法`EXPR_GRAMMAR`。](Grammars.html) 。 如果我们不产生负数，那么将不会测试负数。 如果我们不产生浮点数，那么将不会测试浮点数。 因此，我们的目标必须是*涵盖所有可能的扩展*。

最大化这种多样性的一种方法是*跟踪*在语法生成过程中发生的扩展：如果我们已经看到了某种扩展，则可以从可能的扩展集中选择其他可能的扩展候选。 在我们的表达语法中考虑以下规则：

```py
import [fuzzingbook_utils](https://github.com/uds-se/fuzzingbook/tree/master/notebooks/fuzzingbook_utils)

```

```py
from [Grammars](Grammars.html) import EXPR_GRAMMAR, CGI_GRAMMAR, URL_GRAMMAR, START_SYMBOL
from [Grammars](Grammars.html) import is_valid_grammar, extend_grammar

```

```py
EXPR_GRAMMAR["<factor>"]

```

```py
['+<factor>', '-<factor>', '(<expr>)', '<integer>.<integer>', '<integer>']

```

假设我们已经在`<factor>`的第一个扩展中产生了`<integer>`。 在扩展下一个因子时，我们将标记`<integer>`扩展已被覆盖，并选择尚未发现的替代方法之一，例如`-<factor>`（负数）或`<integer>.<integer>`（浮点数） 。 只有涵盖了所有替代方案后，我们才可以重新考虑以前涵盖的扩展。

### 跟踪语法覆盖率

*语法覆盖率*的概念非常容易实现。 我们引入了一个`GrammarCoverageFuzzer`类，该类跟踪当前已实现的语法覆盖率：

```py
from [GrammarFuzzer](GrammarFuzzer.html) import GrammarFuzzer, all_terminals, nonterminals, display_tree

```

```py
import [random](https://docs.python.org/3/library/random.html)

```

```py
class TrackingGrammarCoverageFuzzer(GrammarFuzzer):
    def __init__(self, *args, **kwargs):
        # invoke superclass __init__(), passing all arguments
        super().__init__(*args, **kwargs)
        self.reset_coverage()

    def reset_coverage(self):
        self.covered_expansions = set()

    def expansion_coverage(self):
        return self.covered_expansions

```

在这组`covered_expansions`中，我们使用函数`expansion_key()`为该对生成一个字符串表示形式，将各个扩展存储为成对的[*符号*，*扩展*）。

```py
def expansion_key(symbol, expansion):
    """Convert (symbol, children) into a key.  `children` can be an expansion string or a derivation tree."""
    if isinstance(expansion, tuple):
        expansion = expansion[0]
    if not isinstance(expansion, str):
        children = expansion
        expansion = all_terminals((symbol, children))
    return symbol + " -> " + expansion

```

```py
expansion_key(START_SYMBOL, EXPR_GRAMMAR[START_SYMBOL][0])

```

```py
'<start> -> <expr>'

```

除了*扩展*之外，我们还可以传递一个子代列表作为参数，然后将其自动转换为字符串。

```py
children = [("<expr>", None), (" + ", []), ("<term>", None)]
expansion_key("<expr>", children)

```

```py
'<expr> -> <expr> + <term>'

```

我们可以通过列举所有扩展来计算语法中可能的扩展集。 方法`max_expansion_coverage()`从给定符号（默认：语法开始符号）开始递归遍历语法，并将所有扩展累积在`expansions`中。 使用`max_depth`参数（默认值：$ \ infty $），我们可以控制语法探索的深度。 在本章的后面，我们将需要它。

```py
class TrackingGrammarCoverageFuzzer(TrackingGrammarCoverageFuzzer):
    def _max_expansion_coverage(self, symbol, max_depth):
        if max_depth <= 0:
            return set()

        self._symbols_seen.add(symbol)

        expansions = set()
        for expansion in self.grammar[symbol]:
            expansions.add(expansion_key(symbol, expansion))
            for nonterminal in nonterminals(expansion):
                if nonterminal not in self._symbols_seen:
                    expansions |= self._max_expansion_coverage(
                        nonterminal, max_depth - 1)

        return expansions

    def max_expansion_coverage(self, symbol=None, max_depth=float('inf')):
        """Return set of all expansions in a grammar starting with `symbol`"""
        if symbol is None:
            symbol = self.start_symbol

        self._symbols_seen = set()
        cov = self._max_expansion_coverage(symbol, max_depth)

        if symbol == START_SYMBOL:
            assert len(self._symbols_seen) == len(self.grammar)

        return cov

```

我们可以使用`max_expansion_coverage()`来计算表达式语法中的所有扩展：

```py
expr_fuzzer = TrackingGrammarCoverageFuzzer(EXPR_GRAMMAR)
expr_fuzzer.max_expansion_coverage()

```

```py
{'<digit> -> 0',
 '<digit> -> 1',
 '<digit> -> 2',
 '<digit> -> 3',
 '<digit> -> 4',
 '<digit> -> 5',
 '<digit> -> 6',
 '<digit> -> 7',
 '<digit> -> 8',
 '<digit> -> 9',
 '<expr> -> <term>',
 '<expr> -> <term> + <expr>',
 '<expr> -> <term> - <expr>',
 '<factor> -> (<expr>)',
 '<factor> -> +<factor>',
 '<factor> -> -<factor>',
 '<factor> -> <integer>',
 '<factor> -> <integer>.<integer>',
 '<integer> -> <digit>',
 '<integer> -> <digit><integer>',
 '<start> -> <expr>',
 '<term> -> <factor>',
 '<term> -> <factor> * <term>',
 '<term> -> <factor> / <term>'}

```

在扩展过程中，我们可以跟踪看到的扩展。 为此，我们使用`choose_node_expansion()`方法，在[语法模糊器](GrammarFuzzer.html)中扩展单个节点。

```py
class TrackingGrammarCoverageFuzzer(TrackingGrammarCoverageFuzzer):
    def add_coverage(self, symbol, new_children):
        key = expansion_key(symbol, new_children)

        if self.log and key not in self.covered_expansions:
            print("Now covered:", key)
        self.covered_expansions.add(key)

    def choose_node_expansion(self, node, possible_children):
        (symbol, children) = node
        index = super().choose_node_expansion(node, possible_children)
        self.add_coverage(symbol, possible_children[index])
        return index

```

方法`missing_expansion_coverage()`是一个辅助方法，它返回仍然必须涵盖的扩展：

```py
class TrackingGrammarCoverageFuzzer(TrackingGrammarCoverageFuzzer):
    def missing_expansion_coverage(self):
        return self.max_expansion_coverage() - self.expansion_coverage()

```

让我们展示跟踪的工作原理。 为简单起见，让我们仅关注`<digit>`扩展。

```py
digit_fuzzer = TrackingGrammarCoverageFuzzer(
    EXPR_GRAMMAR, start_symbol="<digit>", log=True)
digit_fuzzer.fuzz()

```

```py
Tree: <digit>
Expanding <digit> randomly
Now covered: <digit> -> 9
Tree: 9
'9'

```

```py
'9'

```

```py
digit_fuzzer.fuzz()

```

```py
Tree: <digit>
Expanding <digit> randomly
Now covered: <digit> -> 0
Tree: 0
'0'

```

```py
'0'

```

```py
digit_fuzzer.fuzz()

```

```py
Tree: <digit>
Expanding <digit> randomly
Now covered: <digit> -> 5
Tree: 5
'5'

```

```py
'5'

```

到目前为止，这是一组涵盖的扩展：

```py
digit_fuzzer.expansion_coverage()

```

```py
{'<digit> -> 0', '<digit> -> 5', '<digit> -> 9'}

```

这是我们可以涵盖的所有扩展的集合：

```py
digit_fuzzer.max_expansion_coverage()

```

```py
{'<digit> -> 0',
 '<digit> -> 1',
 '<digit> -> 2',
 '<digit> -> 3',
 '<digit> -> 4',
 '<digit> -> 5',
 '<digit> -> 6',
 '<digit> -> 7',
 '<digit> -> 8',
 '<digit> -> 9'}

```

这是缺少的覆盖范围：

```py
digit_fuzzer.missing_expansion_coverage()

```

```py
{'<digit> -> 1',
 '<digit> -> 2',
 '<digit> -> 3',
 '<digit> -> 4',
 '<digit> -> 6',
 '<digit> -> 7',
 '<digit> -> 8'}

```

平均来说，在涵盖所有扩展之后，我们必须产生多少个字符？

```py
def average_length_until_full_coverage(fuzzer):
    trials = 50

    sum = 0
    for trial in range(trials):
        # print(trial, end=" ")
        fuzzer.reset_coverage()
        while len(fuzzer.missing_expansion_coverage()) > 0:
            s = fuzzer.fuzz()
            sum += len(s)

    return sum / trials

```

```py
digit_fuzzer.log = False
average_length_until_full_coverage(digit_fuzzer)

```

```py
28.4

```

对于完整表达式，这需要更长的时间：

```py
expr_fuzzer = TrackingGrammarCoverageFuzzer(EXPR_GRAMMAR)
average_length_until_full_coverage(expr_fuzzer)

```

```py
138.12

```

### 覆盖语法扩展

现在让我们不仅跟踪覆盖范围，而且实际上*产生*覆盖范围。 这个想法如下：

1.  我们确定尚未发现的孩子（在`uncovered_children`中）
2.  如果所有孩子都被覆盖，我们将退回到原始方法（即，随机选择一个扩展）
3.  否则，我们从未发现的孩子中选择一个孩子，并将其标记为覆盖。

为此，我们引入了一个新的模糊器`SimpleGrammarCoverageFuzzer`，它在`choose_node_expansion()`方法中实现了该策略。

```py
class SimpleGrammarCoverageFuzzer(TrackingGrammarCoverageFuzzer):
    def choose_node_expansion(self, node, possible_children):
        # Prefer uncovered expansions
        (symbol, children) = node
        uncovered_children = [c for (i, c) in enumerate(possible_children)
                              if expansion_key(symbol, c) not in self.covered_expansions]
        index_map = [i for (i, c) in enumerate(possible_children)
                     if c in uncovered_children]

        if len(uncovered_children) == 0:
            # All expansions covered - use superclass method
            return self.choose_covered_node_expansion(node, possible_children)

        # Select from uncovered nodes
        index = self.choose_uncovered_node_expansion(node, uncovered_children)

        return index_map[index]

```

为子类提供了两种方法`choose_covered_node_expansion()`和`choose_uncovered_node_expansion()`：

```py
class SimpleGrammarCoverageFuzzer(SimpleGrammarCoverageFuzzer):
    def choose_uncovered_node_expansion(self, node, possible_children):
        return TrackingGrammarCoverageFuzzer.choose_node_expansion(
            self, node, possible_children)

    def choose_covered_node_expansion(self, node, possible_children):
        return TrackingGrammarCoverageFuzzer.choose_node_expansion(
            self, node, possible_children)

```

通过返回到目前为止涵盖的扩展集，我们可以多次调用模糊器，每次都增加语法覆盖率。 例如，使用`EXPR_GRAMMAR`语法产生数字，模糊器产生的数字比另一数字大：

```py
f = SimpleGrammarCoverageFuzzer(EXPR_GRAMMAR, start_symbol="<digit>")
f.fuzz()

```

```py
'5'

```

```py
f.fuzz()

```

```py
'2'

```

```py
f.fuzz()

```

```py
'1'

```

Here's the set of covered expansions so far:

```py
f.expansion_coverage()

```

```py
{'<digit> -> 1', '<digit> -> 2', '<digit> -> 5'}

```

让我们再模糊一些。 我们看到，每次迭代都覆盖了另一个扩展：

```py
for i in range(7):
    print(f.fuzz(), end=" ")

```

```py
0 9 7 4 8 3 6 

```

最后，涵盖所有扩展：

```py
f.missing_expansion_coverage()

```

```py
set()

```

让我们将其应用于更复杂的语法-例如，完整表达语法。 我们看到，经过几次迭代，我们涵盖了每个数字，运算符和扩展：

```py
f = SimpleGrammarCoverageFuzzer(EXPR_GRAMMAR)
for i in range(10):
    print(f.fuzz())

```

```py
+(0.31 / (5) / 9 + 4 * 6 / 3 - 8 - 7) * -2
+++2 / 87360
((4) * 0 - 1) / -9.6 + 7 / 6 + 1 * 8 + 7 * 8
++++26 / -64.45
(8 / 1 / 6 + 9 + 7 + 8) * 1.1 / 0 * 1
7.7
++(3.5 / 3) - (-4 + 3) / (8 / 0) / -4 * 2 / 1
+(90 / --(28 * 8 / 5 + 5 / (5 / 8))) - +9.36 / 2.5 * (5 * (7 * 6 * 5) / 8)
9.11 / 7.28
1 / (9 - 5 * 6) / 6 / 7 / 7 + 1 + 1 - 7 * -3

```

同样，所有扩展都包括在内：

```py
f.missing_expansion_coverage()

```

```py
set()

```

我们看到，与随机方法相比，我们的策略在实现覆盖率方面更为有效：

```py
average_length_until_full_coverage(SimpleGrammarCoverageFuzzer(EXPR_GRAMMAR))

```

```py
52.28

```

## 远见卓识

为单个规则选择扩展是一个好的开始； 但是，如下面的示例所示，这还不够。 我们将覆盖范围的[一章应用于CGI语法的覆盖范围模糊器：](Coverage.html)

```py
CGI_GRAMMAR

```

```py
{'<start>': ['<string>'],
 '<string>': ['<letter>', '<letter><string>'],
 '<letter>': ['<plus>', '<percent>', '<other>'],
 '<plus>': ['+'],
 '<percent>': ['%<hexdigit><hexdigit>'],
 '<hexdigit>': ['0',
  '1',
  '2',
  '3',
  '4',
  '5',
  '6',
  '7',
  '8',
  '9',
  'a',
  'b',
  'c',
  'd',
  'e',
  'f'],
 '<other>': ['0', '1', '2', '3', '4', '5', 'a', 'b', 'c', 'd', 'e', '-', '_']}

```

```py
f = SimpleGrammarCoverageFuzzer(CGI_GRAMMAR)
for i in range(10):
    print(f.fuzz())

```

```py
c
+%a6++
+-
+
++
%18%b7
+e
_
d2+%e3
%d0

```

经过10次迭代，我们仍然发现了许多扩展：

```py
f.missing_expansion_coverage()

```

```py
{'<hexdigit> -> 2',
 '<hexdigit> -> 4',
 '<hexdigit> -> 5',
 '<hexdigit> -> 9',
 '<hexdigit> -> c',
 '<hexdigit> -> f',
 '<other> -> 0',
 '<other> -> 1',
 '<other> -> 3',
 '<other> -> 4',
 '<other> -> 5',
 '<other> -> a',
 '<other> -> b'}

```

为什么会这样？ 问题在于，在CGI语法中，`hexdigit`规则中要涵盖的变体数量最多。 但是，我们首先需要*达到*这种扩展。 扩展`<letter>`符号时，我们可以在三种可能的扩展之间进行选择：

```py
CGI_GRAMMAR["<letter>"]

```

```py
['<plus>', '<percent>', '<other>']

```

如果已经涵盖了所有三个扩展，则上面的`choose_node_expansion()`将随机选择一个-即使选择`<percent>`时可能需要覆盖更多扩展。

我们需要的是一个更好的策略，如果后续有更多未发现的扩展，即使`<percent>`被覆盖，也将选择`<percent>`。 W. Burkhardt [ [Burkhardt *等人*，1967。](https://doi.org/10.1007/BF02235512)]首先以“最短路径选择”的名称讨论了这种策略：

> 此版本从几种开发选择中选择了该语法单元，该语法单元从最短路径开始仍然有一个未使用的单元。

这是我们将在后续步骤中实现的。

### 确定每个符号的最大覆盖范围

为了解决此问题，我们引入了一个基于`SimpleGrammarCoverageFuzzer`的新类`GrammarCoverageFuzzer`，但具有更好的策略。 首先，我们需要计算从特定符号可以达到的*最大扩展集*，正如我们已经在`max_expansion_coverage()`中实现的那样。 我们的想法是稍后计算该集合的*交集*和已经涵盖的展开，以便我们可以偏爱带有非空交集的那些展开。

第一步-计算符号可以达到的最大扩展集-已经实现。 通过将`symbol`参数传递给`max_expansion_coverage()`，我们可以计算每个符号的可能扩展：

```py
f = SimpleGrammarCoverageFuzzer(EXPR_GRAMMAR)
f.max_expansion_coverage('<integer>')

```

```py
{'<digit> -> 0',
 '<digit> -> 1',
 '<digit> -> 2',
 '<digit> -> 3',
 '<digit> -> 4',
 '<digit> -> 5',
 '<digit> -> 6',
 '<digit> -> 7',
 '<digit> -> 8',
 '<digit> -> 9',
 '<integer> -> <digit>',
 '<integer> -> <digit><integer>'}

```

```py
f.max_expansion_coverage('<digit>')

```

```py
{'<digit> -> 0',
 '<digit> -> 1',
 '<digit> -> 2',
 '<digit> -> 3',
 '<digit> -> 4',
 '<digit> -> 5',
 '<digit> -> 6',
 '<digit> -> 7',
 '<digit> -> 8',
 '<digit> -> 9'}

```

### 确定尚未发现的孩子

现在我们可以开始实现`GrammarCoverageFuzzer`。 计算`max_expansion_coverage()`可以让我们确定每个孩子的*失踪覆盖率*。 为此，我们*从可以获得的覆盖范围中减去*已经看到的覆盖范围（`expansion_coverage()`）。

```py
class GrammarCoverageFuzzer(SimpleGrammarCoverageFuzzer):
    def _new_child_coverage(self, children, max_depth):
        new_cov = set()
        for (c_symbol, _) in children:
            if c_symbol in self.grammar:
                new_cov |= self.max_expansion_coverage(
                    c_symbol, max_depth)
        return new_cov

    def new_child_coverage(self, symbol, children, max_depth=float('inf')):
        """Return new coverage that would be obtained by expanding (symbol, children)"""
        new_cov = self._new_child_coverage(children, max_depth)
        new_cov.add(expansion_key(symbol, children))
        new_cov -= self.expansion_coverage()   # -= is set subtraction
        return new_cov

```

让我们说明`new_child_coverage()`。 我们再次开始模糊测试，随机选择扩展。

```py
f = GrammarCoverageFuzzer(EXPR_GRAMMAR, start_symbol="<digit>", log=True)
f.fuzz()

```

```py
Tree: <digit>
Expanding <digit> randomly
Now covered: <digit> -> 2
Tree: 2
'2'

```

```py
'2'

```

这是我们目前的报道：

```py
f.expansion_coverage()

```

```py
{'<digit> -> 2'}

```

当我们查看`<digit>`的单个扩展可能性时，我们看到所有扩展都提供了额外的覆盖范围，*除了*才适用。

```py
for expansion in EXPR_GRAMMAR["<digit>"]:
    children = f.expansion_to_children(expansion)
    print(expansion, f.new_child_coverage("<digit>", children))

```

```py
0 {'<digit> -> 0'}
1 {'<digit> -> 1'}
2 set()
3 {'<digit> -> 3'}
4 {'<digit> -> 4'}
5 {'<digit> -> 5'}
6 {'<digit> -> 6'}
7 {'<digit> -> 7'}
8 {'<digit> -> 8'}
9 {'<digit> -> 9'}

```

这意味着无论何时选择扩展，我们都可以使用`new_child_coverage()`并在提供最大新（看不见）覆盖范围的扩展中进行选择。

### 自适应前瞻

当选择一个孩子时，我们不会期望获得最大的总体覆盖范围，因为这会导致扩展，而许多未发现的可能性将完全主导其他扩展。 相反，我们的目标是采用*广度优先*策略，首先涵盖到达给定深度的所有扩展，然后才寻找更大的深度。 方法`new_coverages()`是此策略的核心：从最大深度（`max_depth`）为零开始，它会增加深度，直到找到至少一个未发现的扩展为止。

```py
class GrammarCoverageFuzzer(GrammarCoverageFuzzer):
    def new_coverages(self, node, possible_children):
        """Return coverage to be obtained for each child at minimum depth"""
        (symbol, children) = node
        for max_depth in range(len(self.grammar)):
            new_coverages = [
                self.new_child_coverage(
                    symbol, c, max_depth) for c in possible_children]
            max_new_coverage = max(len(new_coverage)
                                   for new_coverage in new_coverages)
            if max_new_coverage > 0:
                # Uncovered node found
                return new_coverages

        # All covered
        return None

```

### 全部在一起

现在，我们可以定义`choose_node_expansion()`来使用此策略：首先，我们确定要获得的可能覆盖范围（使用`new_coverages()`）； 然后，我们（随机地）选择运动范围最大的孩子。

```py
class GrammarCoverageFuzzer(GrammarCoverageFuzzer):
    def choose_node_expansion(self, node, possible_children):
        (symbol, children) = node
        new_coverages = self.new_coverages(node, possible_children)

        if new_coverages is None:
            # All expansions covered - use superclass method
            return self.choose_covered_node_expansion(node, possible_children)

        max_new_coverage = max(len(cov) for cov in new_coverages)

        children_with_max_new_coverage = [c for (i, c) in enumerate(possible_children)
                                          if len(new_coverages[i]) == max_new_coverage]
        index_map = [i for (i, c) in enumerate(possible_children)
                     if len(new_coverages[i]) == max_new_coverage]

        # Select a random expansion
        new_children_index = self.choose_uncovered_node_expansion(
            node, children_with_max_new_coverage)
        new_children = children_with_max_new_coverage[new_children_index]

        # Save the expansion as covered
        key = expansion_key(symbol, new_children)

        if self.log:
            print("Now covered:", key)
        self.covered_expansions.add(key)

        return index_map[new_children_index]

```

现在我们的模糊器已经完成。 让我们将其应用于一系列示例。 在表达式上，它可以快速覆盖所有数字和运算符：

```py
f = GrammarCoverageFuzzer(EXPR_GRAMMAR, min_nonterminals=3)
f.fuzz()

```

```py
'-4.02 / (1) * +3 + 5.9 / 7 * 8 - 6'

```

```py
f.max_expansion_coverage() - f.expansion_coverage()

```

```py
set()

```

平均而言，它比简单策略还快：

```py
average_length_until_full_coverage(GrammarCoverageFuzzer(EXPR_GRAMMAR))

```

```py
50.74

```

在CGI语法上，只需几次迭代即可覆盖所有字母和数字：

```py
f = GrammarCoverageFuzzer(CGI_GRAMMAR, min_nonterminals=5)
while len(f.max_expansion_coverage() - f.expansion_coverage()) > 0:
    print(f.fuzz())

```

```py
%18%d03
%c3%94%7f+cd
%a6%b5%e2%5e%4c-54e01a2
%5eb%7cb_ec%a0+

```

通过比较CGI语法的随机，仅扩展和深度预见策略，也可以看到这种改进：

```py
average_length_until_full_coverage(TrackingGrammarCoverageFuzzer(CGI_GRAMMAR))

```

```py
211.34

```

```py
average_length_until_full_coverage(SimpleGrammarCoverageFuzzer(CGI_GRAMMAR))

```

```py
68.64

```

```py
average_length_until_full_coverage(GrammarCoverageFuzzer(CGI_GRAMMAR))

```

```py
40.38

```

## 上下文[的覆盖范围](#Coverage-in-Context)

有时，语法元素会在多个地方使用。 例如，在我们的表达式语法中，`<integer>`符号用于整数以及浮点数：

```py
EXPR_GRAMMAR["<factor>"]

```

```py
['+<factor>', '-<factor>', '(<expr>)', '<integer>.<integer>', '<integer>']

```

如上所定义，我们的覆盖产品将确保覆盖所有`<integer>`扩展（即所有`<digit>`扩展）。 但是，在语法中所有出现的`<integer>`时，单个数字都是*分布*。 如果我们基于覆盖的模糊器产生`1234.56`和`7890`，那么我们将完全覆盖所有数字扩展。 但是，上述`<factor>`扩展中的`<integer>.<integer>`和`<integer>`仅单独覆盖了一部分数字。 如果浮点数和整数具有不同的读取功能，则我们希望对所有这些功能进行全数字测试； 也许我们还希望对浮点数的整个和小数部分进行测试，每个数字都包含数字。

如果我们可以假定该符号的所有出现都得到相同的对待，则忽略使用符号的上下文（在我们的示例中，`<factor>`上下文中`<integer>`和`<digit>`的各种用法）可能很有用。 但是，如果不是，则一种确保符号的出现独立于其他出现而被系统地覆盖的方法是将该出现分配给新符号，该符号是旧符号的*副本*。 我们将首先展示如何手动创建此类重复项，然后介绍一种自动执行此操作的专用功能。

### 手动扩展文法以覆盖上下文

如上所述，一种实现上下文覆盖的简单方法是通过*复制*符号及其引用的规则。 例如，我们可以将`<integer>.<integer>`替换为`<integer-1>.<integer-2>`，并赋予`<integer-1>`和`<integer-2>`与原始`<integer>`相同的定义。 这意味着不仅将覆盖`<integer>`的所有扩展，而且还将覆盖`<integer-1>`和`<integer-2>`的所有扩展。

让我们用实际代码说明这一点：

```py
dup_expr_grammar = extend_grammar(EXPR_GRAMMAR,
                                  {
                                      "<factor>": ["+<factor>", "-<factor>", "(<expr>)", "<integer-1>.<integer-2>", "<integer>"],
                                      "<integer-1>": ["<digit-1><integer-1>", "<digit-1>"],
                                      "<integer-2>": ["<digit-2><integer-2>", "<digit-2>"],
                                      "<digit-1>":
                                      ["0", "1", "2", "3", "4",
                                          "5", "6", "7", "8", "9"],
                                      "<digit-2>":
                                      ["0", "1", "2", "3", "4",
                                          "5", "6", "7", "8", "9"]
                                  }
                                  )

```

```py
assert is_valid_grammar(dup_expr_grammar)

```

如果现在在扩展语法上运行基于覆盖率的模糊器，那么我们将覆盖正整数的所有数字，以及浮点数的整数和小数部分的所有数字：

```py
f = GrammarCoverageFuzzer(dup_expr_grammar, start_symbol="<factor>")
for i in range(10):
    print(f.fuzz())

```

```py
-(43.76 / 8.0 * 5.5 / 6.9 * 6 / 4 + +03)
(90.1 - 1 * 7.3 * 9 + 5 / 8 / 7)
2.8
1.2
10.4
2
4386
7
0
08929.4302

```

我们将看到我们的“有远见”的覆盖率模糊器是如何专门生成浮点数的，该浮点数覆盖整个和小数部分的所有数字。

### 以编程方式扩展文法覆盖上下文

如果我们想增强上下文的覆盖范围，则手动调整语法可能不是理想的选择，因为对语法的任何更改都必须复制在所有重复项中。 取而代之的是，我们引入了一个将为我们做重复的功能。

函数`duplicate_context()`接受语法，语法中的符号以及该符号的扩展名（`None`或未提供：符号的所有扩展名），并且它将扩展名更改为引用所有原始引用规则的副本 。 这个想法是我们以

```py
dup_expr_grammar = extend_grammar(EXPR_GRAMMAR)
duplicate_context(dup_expr_grammar, "<factor>", "<integer>.<integer>")

```

并获得与上述手动更改类似的结果。

这是代码：

```py
from [Grammars](Grammars.html) import new_symbol, unreachable_nonterminals
from [GrammarFuzzer](GrammarFuzzer.html) import expansion_to_children

```

```py
def duplicate_context(grammar, symbol, expansion=None, depth=float('inf')):
    """Duplicate an expansion within a grammar.

 In the given grammar, take the given expansion of the given symbol
 (if expansion is omitted: all symbols), and replace it with a
 new expansion referring to a duplicate of all originally referenced rules.

 If depth is given, limit duplication to `depth` references (default: unlimited)
 """
    orig_grammar = extend_grammar(grammar)
    _duplicate_context(grammar, orig_grammar, symbol,
                       expansion, depth, seen={})

    # After duplication, we may have unreachable rules; delete them
    for nonterminal in unreachable_nonterminals(grammar):
        del grammar[nonterminal]

```

大部分工作都在此辅助功能中进行。 附加参数`seen`跟踪已扩展的符号，并避免无限递归。

```py
import [copy](https://docs.python.org/3/library/copy.html)

```

```py
def _duplicate_context(grammar, orig_grammar, symbol, expansion, depth, seen):
    for i in range(len(grammar[symbol])):
        if expansion is None or grammar[symbol][i] == expansion:
            new_expansion = ""
            for (s, c) in expansion_to_children(grammar[symbol][i]):
                if s in seen:                 # Duplicated already
                    new_expansion += seen[s]
                elif c == [] or depth == 0:   # Terminal symbol or end of recursion
                    new_expansion += s
                else:                         # Nonterminal symbol - duplicate
                    # Add new symbol with copy of rule
                    new_s = new_symbol(grammar, s)
                    grammar[new_s] = copy.deepcopy(orig_grammar[s])

                    # Duplicate its expansions recursively
                    # {**seen, **{s: new_s}} is seen + {s: new_s}
                    _duplicate_context(grammar, orig_grammar, new_s, expansion=None,
                                       depth=depth - 1, seen={**seen, **{s: new_s}})
                    new_expansion += new_s

            grammar[symbol][i] = new_expansion

```

这是我们上面的`duplicate_context()`工作原理示例，现在有了结果。 我们让它在表达式语法中复制`<integer>.<integer>`扩展名，并获得一个带有`<integer-1>.<integer-2>`扩展名的新语法，其中`<integer-1>`和`<integer-2>`都引用原始规则的副本：

```py
dup_expr_grammar = extend_grammar(EXPR_GRAMMAR)
duplicate_context(dup_expr_grammar, "<factor>", "<integer>.<integer>")
dup_expr_grammar

```

```py
{'<start>': ['<expr>'],
 '<expr>': ['<term> + <expr>', '<term> - <expr>', '<term>'],
 '<term>': ['<factor> * <term>', '<factor> / <term>', '<factor>'],
 '<factor>': ['+<factor>',
  '-<factor>',
  '(<expr>)',
  '<integer-1>.<integer-2>',
  '<integer>'],
 '<integer>': ['<digit><integer>', '<digit>'],
 '<digit>': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
 '<integer-1>': ['<digit-1><integer-1>', '<digit-2>'],
 '<digit-1>': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
 '<digit-2>': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
 '<integer-2>': ['<digit-3><integer-2>', '<digit-4>'],
 '<digit-3>': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
 '<digit-4>': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']}

```

就像上面一样，使用这样的语法进行覆盖模糊处理现在将覆盖许多上下文中的数字。 准确地说，有五个上下文：正则整数，以及浮点数的一位和多位整数和小数部分。

```py
f = GrammarCoverageFuzzer(dup_expr_grammar, start_symbol="<factor>")
for i in range(10):
    print(f.fuzz())

```

```py
(57.5)
2
+-(1 / 3 + 6 / 0 - 7 * 59 * 3 + 8 * 4)
374.88
5.709
0.93
01.1
892.27
219.50
6.636

```

`depth`参数控制复制应进行的深度。 将`depth`设置为1只会复制下一条规则：

```py
dup_expr_grammar = extend_grammar(EXPR_GRAMMAR)
duplicate_context(dup_expr_grammar, "<factor>", "<integer>.<integer>", depth=1)
dup_expr_grammar

```

```py
{'<start>': ['<expr>'],
 '<expr>': ['<term> + <expr>', '<term> - <expr>', '<term>'],
 '<term>': ['<factor> * <term>', '<factor> / <term>', '<factor>'],
 '<factor>': ['+<factor>',
  '-<factor>',
  '(<expr>)',
  '<integer-1>.<integer-2>',
  '<integer>'],
 '<integer>': ['<digit><integer>', '<digit>'],
 '<digit>': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
 '<integer-1>': ['<digit><integer-1>', '<digit>'],
 '<integer-2>': ['<digit><integer-2>', '<digit>']}

```

```py
assert is_valid_grammar(dup_expr_grammar)

```

默认情况下，`depth`设置为$ \ infty $，表示无限复制。 真正的无界重复可能会导致诸如`EXPR_GRAMMAR`之类的递归语法出现问题，因此一旦将`duplicate_context()`设置为不再重复的符号。 尽管如此，如果我们将其应用于所有 `<expr>`扩展的*重复项，我们将获得不少于296条规则的语法：*

```py
dup_expr_grammar = extend_grammar(EXPR_GRAMMAR)
duplicate_context(dup_expr_grammar, "<expr>")

```

```py
assert is_valid_grammar(dup_expr_grammar)
len(dup_expr_grammar)

```

```py
292

```

这使我们可以扩展将近2000个范围：

```py
f = GrammarCoverageFuzzer(dup_expr_grammar)
len(f.max_expansion_coverage())

```

```py
1981

```

再重复一遍，既使语法又提高了覆盖率要求：

```py
dup_expr_grammar = extend_grammar(EXPR_GRAMMAR)
duplicate_context(dup_expr_grammar, "<expr>")
duplicate_context(dup_expr_grammar, "<expr-1>")
len(dup_expr_grammar)

```

```py
594

```

```py
f = GrammarCoverageFuzzer(dup_expr_grammar)
len(f.max_expansion_coverage())

```

```py
3994

```

在这一点上，可以单独涵盖很多上下文，例如，加法中元素的乘法：

```py
dup_expr_grammar["<expr>"]

```

```py
['<term-1> + <expr-4>', '<term-5> - <expr-8>', '<term-9>']

```

```py
dup_expr_grammar["<term-1-1>"]

```

```py
['<factor-1-1> * <term-1-1>', '<factor-2-1> / <term-1-1>', '<factor-3-1>']

```

```py
dup_expr_grammar["<factor-1-1>"]

```

```py
['+<factor-1-1>',
 '-<factor-1-1>',
 '(<expr-1-1>)',
 '<integer-1-1>.<integer-2-1>',
 '<integer-3-1>']

```

产生的语法可能不再对人类维护有用； 但是运行覆盖率驱动的模糊器（例如`GrammarCoverageFuzzer()`）将可以覆盖所有情况下的所有这些扩展。 如果您想覆盖大量上下文中的元素，那么`duplicate_context()`和覆盖率驱动的模糊器是您的朋友。

## 通过覆盖语法来覆盖代码

有无上下文：通过系统地覆盖所有输入元素，我们可以在输入中获得更大的种类-但这是否会转化为更广泛的程序行为？ 毕竟，这些行为是我们要涵盖的，包括意外行为。

在语法中，有些元素直接对应于程序功能。 处理算术表达式的程序将具有直接由各个元素触发的功能-例如，由`+`存在触发的加法功能，由`-`存在触发的减法和由`-`存在触发的浮点算术 输入中的浮点数。

输入结构和功能之间的这种联系导致语法覆盖范围和代码覆盖范围之间具有很强的*相关性。 换句话说：如果我们可以实现较高的语法覆盖率，那么这也将导致较高的代码覆盖率。*

### CGI语法

让我们在我们的一种语法中探索这种关系，例如，关于覆盖范围的[章中的CGI解码器。 我们计算映射`coverages`，其中在`coverages[x]` = `{y_1, y_2, ...}`中，`x`是获得的语法覆盖率，`y_n`是从第`n`次运行获得的代码覆盖率。](Coverage.html)

我们首先计算最大覆盖率，如关于覆盖率的[一章：](Coverage.html)

```py
from [Coverage](Coverage.html) import Coverage, cgi_decode

```

```py
with Coverage() as cov_max:
    cgi_decode('+')
    cgi_decode('%20')
    cgi_decode('abc')
    try:
        cgi_decode('%?a')
    except:
        pass

```

现在，我们进行实验：

```py
f = GrammarCoverageFuzzer(CGI_GRAMMAR, max_nonterminals=2)
coverages = {}

trials = 100
for trial in range(trials):
    f.reset_coverage()
    overall_cov = set()
    max_cov = 30

    for i in range(10):
        s = f.fuzz()
        with Coverage() as cov:
            cgi_decode(s)
        overall_cov |= cov.coverage()

        x = len(f.expansion_coverage()) * 100 / len(f.max_expansion_coverage())
        y = len(overall_cov) * 100 / len(cov_max.coverage())
        if x not in coverages:
            coverages[x] = []
        coverages[x].append(y)

```

我们计算`y`值的平均值：

```py
xs = list(coverages.keys())
ys = [sum(coverages[x]) / len(coverages[x]) for x in coverages]

```

并创建散点图：

```py
%matplotlib inline

```

```py
import [matplotlib.pyplot](https://docs.python.org/3/library/matplotlib.pyplot.html) as [plt](https://docs.python.org/3/library/plt.html)

```

```py
import [matplotlib.ticker](https://docs.python.org/3/library/matplotlib.ticker.html) as [mtick](https://docs.python.org/3/library/mtick.html)

```

```py
ax = plt.axes(label="coverage")
ax.yaxis.set_major_formatter(mtick.PercentFormatter())
ax.xaxis.set_major_formatter(mtick.PercentFormatter())

plt.xlim(0, max(xs))
plt.ylim(0, max(ys))

plt.title('Coverage of cgi_decode() vs. grammar coverage')
plt.xlabel('grammar coverage (expansions)')
plt.ylabel('code coverage (lines)')
plt.scatter(xs, ys);

```

![](data:image/png;base64,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
)

我们看到语法覆盖率越高，代码覆盖率越高。

这也将转化为约0.9的相关系数，表明相关性很强：

```py
import [numpy](https://docs.python.org/3/library/numpy.html) as [np](https://docs.python.org/3/library/np.html)

```

```py
np.corrcoef(xs, ys)

```

```py
array([[1\.        , 0.81663071],
       [0.81663071, 1\.        ]])

```

Spearman等级相关性也证实了这一点：

```py
from [scipy.stats](https://docs.python.org/3/library/scipy.stats.html) import spearmanr

```

```py
spearmanr(xs, ys)

```

```py
SpearmanrResult(correlation=0.937547293248041, pvalue=1.0928720949027369e-09)

```

### URL语法

让我们在URL语法上重复此实验。 除了交换语法和功能外，我们使用与上述相同的代码：

```py
try:
    from [urlparse](https://docs.python.org/3/library/urlparse.html) import urlparse      # Python 2
except ImportError:
    from [urllib.parse](https://docs.python.org/3/library/urllib.parse.html) import urlparse  # Python 3

```

再次，我们首先计算最大覆盖率，如关于覆盖率的[一章所述，进行有根据的猜测：](Coverage.html)

```py
with Coverage() as cov_max:
    urlparse("http://foo.bar/path")
    urlparse("https://foo.bar#fragment")
    urlparse("ftp://user:password@foo.bar?query=value")
    urlparse("ftps://127.0.0.1/?x=1&y=2")

```

这是实际的实验：

```py
f = GrammarCoverageFuzzer(URL_GRAMMAR, max_nonterminals=2)
coverages = {}

trials = 100
for trial in range(trials):
    f.reset_coverage()
    overall_cov = set()

    for i in range(20):
        s = f.fuzz()
        with Coverage() as cov:
            urlparse(s)
        overall_cov |= cov.coverage()

        x = len(f.expansion_coverage()) * 100 / len(f.max_expansion_coverage())
        y = len(overall_cov) * 100 / len(cov_max.coverage())
        if x not in coverages:
            coverages[x] = []
        coverages[x].append(y)

```

```py
xs = list(coverages.keys())
ys = [sum(coverages[x]) / len(coverages[x]) for x in coverages]

```

```py
ax = plt.axes(label="coverage")
ax.yaxis.set_major_formatter(mtick.PercentFormatter())
ax.xaxis.set_major_formatter(mtick.PercentFormatter())

plt.xlim(0, max(xs))
plt.ylim(0, max(ys))

plt.title('Coverage of urlparse() vs. grammar coverage')
plt.xlabel('grammar coverage (expansions)')
plt.ylabel('code coverage (lines)')
plt.scatter(xs, ys);

```

![](data:image/png;base64,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
)

在这里，我们的相关系数甚至超过了0.95：

```py
np.corrcoef(xs, ys)

```

```py
array([[1\.        , 0.94110679],
       [0.94110679, 1\.        ]])

```

This is also confirmed by the Spearman rank correlation:

```py
spearmanr(xs, ys)

```

```py
SpearmanrResult(correlation=1.0, pvalue=0.0)

```

我们得出的结论是：如果要获得较高的代码覆盖率，则首先争取较高的语法覆盖率是一个好主意。

### 这会一直有效吗？

对于CGI和URL示例观察到的相关性并不适用于每个程序和每个结构。

#### 等效元素

首先，即使某个语法元素将它们视为不同的符号，它们也会被程序统一处理。 例如，在URL的主机名中，我们可以有许多不同的字符，尽管URL处理程序将它们完全相同。 同样，单个数字一旦组合成一个数字，其影响就小于数字本身的值。 因此，实现数字或字符的多样性不一定会在功能上产生很大的差异。

如上所述，可以通过*取决于元素的上下文*区分元素并覆盖每种上下文的替代方案来解决此问题。 关键是确定需要多样性的环境，而不是不需要多样性的环境。

#### 深度数据处理

其次，数据的处理方式可能会有很大的不同。 考虑到*媒体播放器*的输入，该输入由压缩的媒体数据组成。 在处理媒体数据时，媒体播放器将显示行为上的差异（特别是在其输出中），但是无法通过媒体数据的各个元素直接触发这些差异。 同样，在大量输入上训练的*机器学习器*通常不会通过输入的单个语法元素来控制其行为。 （嗯，可以，但是然后，我们将不需要机器学习者。）在“深度”数据处理的这些情况下，在语法上实现结构覆盖不一定会导致代码覆盖。

解决此问题的一种方法不仅是实现*语法*，而且实际上是*语义*变体。 在[关于带约束的模糊化](GeneratorGrammarFuzzer.html)的章节中，我们将看到如何专门生成和过滤输入值，尤其是数值。 这样的生成器也可以在上下文中应用，从而可以分别控制输入的每个方面。 同样，在以上示例中，*输入的某些*部分仍可以在结构上覆盖：*元数据*（例如媒体播放器的作者姓名或作曲者）或*配置数据[* （例如机器学习者的设置）可以并且应该被系统地涵盖； 我们将在“配置模糊” 一章中看到如何完成此操作。

## 经验教训

*   快速实现*语法覆盖率*会产生各种各样的输入。
*   复制语法规则允许覆盖特定*上下文*中的元素。
*   实现语法覆盖率可以帮助获得*代码覆盖率*。

## 后续步骤

从这里，您可以学习如何

*   [使用语法覆盖系统地测试配置](ConfigurationFuzzer.html)。

## 背景

确保语法中的每个扩展至少使用一次的想法可以追溯到Burkhardt [ [Burkhardt *等人*，1967。](https://doi.org/10.1007/BF02235512)]，稍后由Paul Purdom [[重新发现。 Purdom *等*，1972。](https://doi.org/10.1007/BF01932308)。 语法覆盖率和代码覆盖率之间的关系是由Nikolas Havrikov发现的，他在其博士学位论文中对此进行了探讨。

## 练习

### 练习1：测试ls

考虑用于列出目录内容的Unix `ls`程序。 创建用于调用`ls`的语法：

```py
LS_EBNF_GRAMMAR = {
    '<start>': ['-<options>'],
    '<options>': ['<option>*'],
    '<option>': ['1', 'A', '@',
                 # many more
                 ]
}

```

```py
assert is_valid_grammar(LS_EBNF_GRAMMAR)

```

使用`GrammarCoverageFuzzer`测试所有选项。 确保在每个选项集中都调用`ls`。

[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/master?filepath=docs/notebooks/GrammarCoverageFuzzer.ipynb#Exercises) to work on the exercises and see solutions.

### 练习2：缓存

`max_expansion_coverage()`的值仅取决于语法。 更改实现，以便在初始化时为每个符号和深度预先计算值（`__init__()`）； 这样，`max_expansion_coverage()`可以简单地在表中查找值。

[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/master?filepath=docs/notebooks/GrammarCoverageFuzzer.ipynb#Exercises) to work on the exercises and see solutions.