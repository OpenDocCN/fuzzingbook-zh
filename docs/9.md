# 代码覆盖率

> 原文： [https://www.fuzzingbook.org/html/Coverage.html](https://www.fuzzingbook.org/html/Coverage.html)

在[的前一章](Fuzzer.html)中，我们介绍了*基本模糊处理*-即生成用于测试程序的随机输入。 我们如何衡量这些测试的有效性？ 一种方法是检查发现的错误的数量（和严重性）。 但是如果错误很少，我们需要一个*代理来进行测试以发现错误。* 在本章中，我们介绍*代码覆盖率*的概念，该概念衡量在测试运行期间实际执行程序的哪些部分。 对于尝试覆盖尽可能多的代码的测试生成器，衡量此类覆盖范围也至关重要。

**前提条件**

*   您需要对程序的执行方式有所了解。
*   您应该已经在[上一章](Fuzzer.html)中了解了基本的模糊测试。

## 内容提要

要使用本章中提供的代码来[，请编写](Importing.html)

```py
>>> from [fuzzingbook.Coverage](Coverage.html) import <identifier>

```

然后利用以下功能。

本章介绍`Coverage`类，使您可以测量Python程序的覆盖率。 它的典型用法是与`with`子句结合使用：

```py
>>> with Coverage() as cov:
>>>     cgi_decode("a+b")

```

`trace()`方法将覆盖率作为覆盖位置的列表返回。 每个位置成对出现（`function name`和`line`）。

```py
>>> print(cov.trace())
[('cgi_decode', 9), ('cgi_decode', 10), ('cgi_decode', 11), ('cgi_decode', 12), ('cgi_decode', 15), ('cgi_decode', 16), ('cgi_decode', 17), ('cgi_decode', 18), ('cgi_decode', 19), ('cgi_decode', 21), ('cgi_decode', 30), ('cgi_decode', 31), ('cgi_decode', 17), ('cgi_decode', 18), ('cgi_decode', 19), ('cgi_decode', 20), ('cgi_decode', 31), ('cgi_decode', 17), ('cgi_decode', 18), ('cgi_decode', 19), ('cgi_decode', 21), ('cgi_decode', 30), ('cgi_decode', 31), ('cgi_decode', 17), ('cgi_decode', 32), ('__exit__', 25)]

```

`coverage()`方法返回至少执行一次的位置集：

```py
>>> print(cov.coverage())
{('cgi_decode', 12), ('cgi_decode', 20), ('cgi_decode', 30), ('cgi_decode', 21), ('cgi_decode', 32), ('cgi_decode', 31), ('cgi_decode', 10), ('__exit__', 25), ('cgi_decode', 11), ('cgi_decode', 18), ('cgi_decode', 9), ('cgi_decode', 19), ('cgi_decode', 16), ('cgi_decode', 15), ('cgi_decode', 17)}

```

## CGI解码器

我们首先介绍一个简单的Python函数，该函数对CGI编码的字符串进行解码。 URL（即网址）中使用CGI编码来编码URL中无效的字符，例如空格和某些标点符号：

*   空白由`'+'`代替
*   其他无效字符将替换为“ `%xx`”，其中`xx`是两位十六进制等效项。

因此，在CGI编码中，字符串`"Hello, world!"`将变成`"Hello%2c+world%21"`，其中`2c`和`21`分别是`','`和`'!'`的十六进制等效项。

函数`cgi_decode()`接受这样的编码字符串，并将其解码回其原始形式。 我们的实现复制了[[Pezzè*等人*，2008。](http://ix.cs.uoregon.edu/~michal/book/)]中的代码。 （它甚至包括其错误-但我们目前不会公开它们。）

```py
def cgi_decode(s):
    """Decode the CGI-encoded string `s`:
 * replace "+" by " "
 * replace "%xx" by the character with hex number xx.
 Return the decoded string.  Raise `ValueError` for invalid inputs."""

    # Mapping of hex digits to their integer values
    hex_values = {
        '0': 0, '1': 1, '2': 2, '3': 3, '4': 4,
        '5': 5, '6': 6, '7': 7, '8': 8, '9': 9,
        'a': 10, 'b': 11, 'c': 12, 'd': 13, 'e': 14, 'f': 15,
        'A': 10, 'B': 11, 'C': 12, 'D': 13, 'E': 14, 'F': 15,
    }

    t = ""
    i = 0
    while i < len(s):
        c = s[i]
        if c == '+':
            t += ' '
        elif c == '%':
            digit_high, digit_low = s[i + 1], s[i + 2]
            i += 2
            if digit_high in hex_values and digit_low in hex_values:
                v = hex_values[digit_high] * 16 + hex_values[digit_low]
                t += chr(v)
            else:
                raise ValueError("Invalid encoding")
        else:
            t += c
        i += 1
    return t

```

这是`cgi_decode()`的工作方式示例：

```py
cgi_decode("Hello+world")

```

```py
'Hello world'

```

如果我们要系统地测试`cgi_decode()`，我们将如何进行？

测试文献区分了两种派生测试的方式：*黑盒测试*和*白盒测试。*

## 黑匣子测试

*黑盒测试*的想法是从*规范*派生测试。 在上述情况下，我们将不得不通过指定和记录的功能来测试`cgi_decode()`，包括

*   测试是否正确替换`'+'`；
*   测试是否正确替换`"%xx"`；
*   测试是否替换其他字符； 和
*   测试识别非法输入。

这是涵盖这四个功能的四个断言（测试）。 我们可以看到它们全部通过：

```py
assert cgi_decode('+') == ' '
assert cgi_decode('%20') == ' '
assert cgi_decode('abc') == 'abc'

try:
    cgi_decode('%?a')
    assert False
except ValueError:
    pass

```

黑匣子测试的优势在于，它可以发现*指定的*行为中的错误。 它独立于给定的实现，因此即使在实现之前也可以创建测试。 不利之处在于，*实现的*行为通常比*指定的*行为覆盖更多的领域，因此仅基于规范的测试通常不会涵盖所有实现细节。

## 白盒测试

与黑盒测试相反，*白盒测试*从*实现*中得出测试，尤其是内部结构。 白盒测试与*的概念紧密相关，后者涵盖了代码的*结构特征。 例如，如果在测试过程中未执行代码中的语句，则意味着该语句中的错误也无法触发。 因此，白盒测试引入了许多必须满足的*覆盖标准*。 最常用的覆盖标准是

*   *语句覆盖率*-代码中的每个语句必须至少由一个测试输入执行。
*   *分支覆盖*-代码中的每个分支必须至少由一个测试输入进行。 （这将转换为每个`if`和`while`决策一次为真，一次为假。）

除此之外，还有更多的覆盖标准，包括采用的分支顺序，采用的循环迭代（零次，一次，多次），变量定义和用法之间的数据流等等。 [[Pezzè*等*，2008。](http://ix.cs.uoregon.edu/~michal/book/)]进行了很好的概述。

让我们考虑上面的`cgi_decode()`并说明必须要做的事情，以使每个代码语句至少执行一次。 我们必须掩盖

*   `if c == '+'`之后的程序段
*   `if c == '%'`之后的两个块（一个为有效输入，一个为无效输入）
*   所有其他字符的最后`else`大小写。

这导致了与上述黑盒测试相同的条件； 同样，以上断言确实涵盖了代码中的每个语句。 由于程序员倾向于在不同的代码位置实现不同的行为，因此这种对应实际上很常见。 因此，覆盖这些位置将导致测试用例涵盖不同的（指定的）行为。

白盒测试的优势在于它可以发现*实现的*行为中的错误。 即使规范中没有提供足够的细节，也可以执行此操作； 实际上，它有助于识别（从而指定）规范中的极端情况。 缺点是它可能会错过*未实现的*行为：如果缺少某些指定的功能，白盒测试将找不到它。

## 跟踪执行

白盒测试的一个不错的功能是，它实际上可以自动评估是否涵盖了某些程序功能。 为此，一个*指示*该程序的执行，以便在执行期间，一种特殊的功能可以跟踪执行了哪些代码。 在测试之后，这些信息可以传递给程序员，然后程序员可以专注于编写涵盖尚未发现的代码的测试。

在大多数编程语言中，要设置程序以跟踪其执行是相当困难的。 在Python中不是这样。 函数`sys.settrace(f)`允许定义*跟踪函数* `f()`，该函数将为每条执行的每一行调用。 更好的是，它可以访问当前函数及其名称，当前变量内容等。 因此，它是*动态分析*的理想工具-即分析执行过程中实际发生的情况。

为了说明它是如何工作的，让我们再次查看`cgi_decode()`的特定执行。

```py
cgi_decode("a+b")

```

```py
'a b'

```

为了跟踪执行如何通过`cgi_decode()`进行，我们使用`sys.settrace()`。 首先，我们定义将为每行调用的*跟踪函数*。 它具有三个参数：

*   `frame`参数为您提供当前*帧*，允许访问当前位置和变量：
    *   `frame.f_code`是当前执行的代码，其中`frame.f_code.co_name`是函数名；
    *   `frame.f_lineno`保留当前行号； 和
    *   `frame.f_locals`保存当前的局部变量和参数。
*   `event`参数是一个字符串，其值包括`"line"`（到达新行）或`"call"`（正在调用函数）。
*   `arg`参数是某些事件的附加*参数*； 例如，对于`"return"`事件，`arg`保存所返回的值。

我们使用跟踪函数来简单地报告当前执行的行，我们可以通过`frame`参数对其进行访问。

```py
coverage = []

```

```py
def traceit(frame, event, arg):
    if event == "line":
        global coverage
        function_name = frame.f_code.co_name
        lineno = frame.f_lineno
        coverage.append(lineno)
    return traceit

```

我们可以使用`sys.settrace()`打开和关闭跟踪：

```py
import [sys](https://docs.python.org/3/library/sys.html)

```

```py
def cgi_decode_traced(s):
    global coverage
    coverage = []
    sys.settrace(traceit)  # Turn on
    cgi_decode(s)
    sys.settrace(None)    # Turn off

```

当我们计算`cgi_decode("a+b")`时，我们现在可以看到执行过程如何通过`cgi_decode()`进行。 在`hex_values`，`t`和`i`初始化之后，我们看到`while`循环被执行了3次–输入中的每个字符一次。

```py
cgi_decode_traced("a+b")
print(coverage)

```

```py
[9, 10, 11, 12, 15, 16, 17, 18, 19, 21, 30, 31, 17, 18, 19, 20, 31, 17, 18, 19, 21, 30, 31, 17, 32]

```

这些到底是哪几行？ 为此，我们获得了`cgi_decode_code`的源代码并将其编码到数组`cgi_decode_lines`中，然后使用覆盖率信息对其进行注释。 首先，让我们获取`cgi_encode`的源代码：

```py
import [inspect](https://docs.python.org/3/library/inspect.html)

```

```py
cgi_decode_code = inspect.getsource(cgi_decode)

```

`cgi_decode_code`是包含源代码的字符串。 我们可以使用Python语法高亮显示它：

```py
from [fuzzingbook_utils](https://github.com/uds-se/fuzzingbook/tree/master/notebooks/fuzzingbook_utils) import print_content, print_file

```

```py
print_content(cgi_decode_code[:300] + "...", ".py")

```

```py
def cgi_decode(s):
    """Decode the CGI-encoded string `s`:
 * replace "+" by " "
 * replace "%xx" by the character with hex number xx.
 Return the decoded string.  Raise `ValueError` for invalid inputs."""

    # Mapping of hex digits to their integer values
    hex_values = {
  ...

```

使用`splitlines()`，我们将代码分成几行，并按行号索引。

```py
cgi_decode_lines = [""] + cgi_decode_code.splitlines()

```

`cgi_decode_lines[L]`是源代码的L行。

```py
cgi_decode_lines[1]

```

```py
'def cgi_decode(s):'

```

我们看到执行的第一行（9）实际上是`hex_values`的初始化...

```py
cgi_decode_lines[9:13]

```

```py
["        '0': 0, '1': 1, '2': 2, '3': 3, '4': 4,",
 "        '5': 5, '6': 6, '7': 7, '8': 8, '9': 9,",
 "        'a': 10, 'b': 11, 'c': 12, 'd': 13, 'e': 14, 'f': 15,",
 "        'A': 10, 'B': 11, 'C': 12, 'D': 13, 'E': 14, 'F': 15,"]

```

...然后初始化`t`：

```py
cgi_decode_lines[15]

```

```py
'    t = ""'

```

要查看实际上至少覆盖了哪些行，我们可以将`coverage`转换为一组：

```py
covered_lines = set(coverage)
print(covered_lines)

```

```py
{32, 9, 10, 11, 12, 15, 16, 17, 18, 19, 20, 21, 30, 31}

```

让我们打印出完整的代码，注释未用'＃'覆盖的行：

```py
for lineno in range(1, len(cgi_decode_lines)):
    if lineno not in covered_lines:
        print("# ", end="")
    else:
        print("  ", end="")
    print("%2d " % lineno, end="")
    print_content(cgi_decode_lines[lineno], '.py')

```

```py
#  1  def cgi_decode(s):
#  2      """Decode the CGI-encoded string `s`:
#  3         * replace "+" by "  "
#  4         * replace "%xx" by the character with hex number xx.
#  5         Return the decoded string.  Raise `ValueError` for invalid inputs."""
#  6  
#  7      # Mapping of hex digits to their integer values
#  8      hex_values = {
   9          '0': 0, '1': 1, '2': 2, '3': 3, '4': 4,
  10          '5': 5, '6': 6, '7': 7, '8': 8, '9': 9,
  11          'a': 10, 'b': 11, 'c': 12, 'd': 13, 'e': 14, 'f': 15,
  12          'A': 10, 'B': 11, 'C': 12, 'D': 13, 'E': 14, 'F': 15,
# 13      }
# 14  
  15      t = ""
  16      i = 0
  17      while i < len(s):
  18          c = s[i]
  19          if c == '+':
  20              t += '  '
  21          elif c == '%':
# 22              digit_high, digit_low = s[i + 1], s[i + 2]
# 23              i += 2
# 24              if digit_high in hex_values and digit_low in hex_values:
# 25                  v = hex_values[digit_high] * 16 + hex_values[digit_low]
# 26                  t += chr(v)
# 27              else:
# 28                  raise ValueError("Invalid encoding")
# 29          else:
  30              t += c
  31          i += 1
  32      return t

```

我们看到许多行（尤其是注释）尚未执行，仅仅是因为它们不是可执行的。 但是，我们还看到`if c == '%'`下的行尚未执行*。 如果`"a+b"`是到目前为止我们唯一的测试用例，那么缺少的覆盖范围现在将鼓励我们创建另一个实际上覆盖这些行的测试用例。*

## 覆盖等级

在本书中，我们将一次又一次地使用覆盖率-*测量*不同测试生成技术的有效性，同时*指导*测试生成朝代码覆盖率发展。 之前我们使用全局`coverage`变量的实现有点麻烦。 因此，我们实现了一些功能，这些功能将有助于我们轻松衡量覆盖率。

获得覆盖率的关键思想是利用Python `with`语句。 一般形式

```py
with OBJECT [as VARIABLE]:
    BODY

```

在定义了`OBJECT`（并存储在`VARIABLE`中）的情况下执行`BODY`。 有趣的是，在`BODY`的开头和结尾，会自动调用特殊方法`OBJECT.__enter__()`和`OBJECT.__exit__()`； 即使`BODY`引发异常。 这使我们可以定义`Coverage`对象，其中`Coverage.__enter__()`自动打开跟踪，而`Coverage.__exit__()`自动关闭跟踪。 跟踪之后，我们可以使用特殊方法来访问coverage。 这是在使用过程中的样子：

```py
with Coverage() as cov:
    function_to_be_traced()
c = cov.coverage()

```

在此，跟踪在`function_to_be_traced()`期间自动打开，在`with`块之后再次关闭。 之后，我们可以访问执行的行集。

这是所有实现过程的全部内容。 您不必全力以赴。 您知道如何使用它即可：

```py
class Coverage(object):
    # Trace function
    def traceit(self, frame, event, arg):
        if self.original_trace_function is not None:
            self.original_trace_function(frame, event, arg)

        if event == "line":
            function_name = frame.f_code.co_name
            lineno = frame.f_lineno
            self._trace.append((function_name, lineno))

        return self.traceit

    def __init__(self):
        self._trace = []

    # Start of `with` block
    def __enter__(self):
        self.original_trace_function = sys.gettrace()
        sys.settrace(self.traceit)
        return self

    # End of `with` block
    def __exit__(self, exc_type, exc_value, tb):
        sys.settrace(self.original_trace_function)

    def trace(self):
        """The list of executed lines, as (function_name, line_number) pairs"""
        return self._trace

    def coverage(self):
        """The set of executed lines, as (function_name, line_number) pairs"""
        return set(self.trace())

```

让我们使用它：

```py
with Coverage() as cov:
    cgi_decode("a+b")

print(cov.coverage())

```

```py
{('cgi_decode', 12), ('cgi_decode', 20), ('cgi_decode', 30), ('cgi_decode', 21), ('cgi_decode', 32), ('cgi_decode', 31), ('cgi_decode', 10), ('__exit__', 25), ('cgi_decode', 11), ('cgi_decode', 18), ('cgi_decode', 9), ('cgi_decode', 19), ('cgi_decode', 16), ('cgi_decode', 15), ('cgi_decode', 17)}

```

如您所见，`Coverage()`类不仅跟踪执行的行，而且跟踪函数名。 如果您有一个跨多个文件的程序，这将很有用。

## 比较覆盖率

由于我们将覆盖范围表示为一组已执行的行，因此我们也可以在其上应用*设置操作*。 例如，我们可以找出单个测试用例涵盖哪些行，而其他测试用例则不行：

```py
with Coverage() as cov_plus:
    cgi_decode("a+b")
with Coverage() as cov_standard:
    cgi_decode("abc")

cov_plus.coverage() - cov_standard.coverage()

```

```py
{('cgi_decode', 20)}

```

这是仅在`'a+b'`输入中执行的代码中的单行。

我们还可以比较集合以找出哪些行仍需要覆盖。 让我们将`cov_max`定义为我们可以达到的最大覆盖范围。 （在这里，我们通过执行已经存在的“好”测试用例来执行此操作。在实践中，我们将静态分析代码结构，我们在[中引入了有关符号测试](SymbolicFuzzer.html)的章节。）

```py
import [fuzzingbook_utils](https://github.com/uds-se/fuzzingbook/tree/master/notebooks/fuzzingbook_utils)

```

```py
with Coverage() as cov_max:
    cgi_decode('+')
    cgi_decode('%20')
    cgi_decode('abc')
    try:
        cgi_decode('%?a')
    except:
        pass

```

然后，我们可以轻松查看哪些用例尚未覆盖*而不是*的行：

```py
cov_max.coverage() - cov_plus.coverage()

```

```py
{('cgi_decode', 22),
 ('cgi_decode', 23),
 ('cgi_decode', 24),
 ('cgi_decode', 25),
 ('cgi_decode', 26),
 ('cgi_decode', 28)}

```

同样，这些将是处理`"%xx"`的行，我们尚未在输入中包含这些行。

## 基本模糊测试的范围

现在，我们可以使用覆盖范围跟踪来评估测试方法的*有效性*-特别是当然要测试*生成*方法。 我们的挑战是仅使用随机输入就可以在`cgi_decode()`中获得最大的覆盖范围。 原则上，我们应该*最终*到达那里，因为最终我们将产生出宇宙中所有可能的弦-但是这到底是多长时间？ 为此，让我们在`cgi_decode()`上仅运行一个模糊的迭代：

```py
from [Fuzzer](Fuzzer.html) import fuzzer

```

```py
sample = fuzzer()
sample

```

```py
'!7#%"*#0=)$;%6*;>638:*>80"=</>(/*:-(2<4 !:5*6856&?""11<7+%<%7,4.8,*+&,,$,."'

```

这是我们实现的调用和范围。 我们将`cgi_decode()`包装在`try...except`块中，以便我们可以忽略由非法`%xx`格式引发的`ValueError`异常。

```py
with Coverage() as cov_fuzz:
    try:
        cgi_decode(sample)
    except:
        pass
cov_fuzz.coverage()

```

```py
{('__exit__', 25),
 ('cgi_decode', 9),
 ('cgi_decode', 10),
 ('cgi_decode', 11),
 ('cgi_decode', 12),
 ('cgi_decode', 15),
 ('cgi_decode', 16),
 ('cgi_decode', 17),
 ('cgi_decode', 18),
 ('cgi_decode', 19),
 ('cgi_decode', 21),
 ('cgi_decode', 22),
 ('cgi_decode', 23),
 ('cgi_decode', 24),
 ('cgi_decode', 28),
 ('cgi_decode', 30),
 ('cgi_decode', 31)}

```

这已经是最大覆盖范围了吗？ 显然，仍然缺少以下行：

```py
cov_max.coverage() - cov_fuzz.coverage()

```

```py
{('cgi_decode', 20),
 ('cgi_decode', 25),
 ('cgi_decode', 26),
 ('cgi_decode', 32)}

```

让我们再试一次，增加100个随机输入的覆盖范围。 我们使用数组`cumulative_coverage`存储随着时间的推移所达到的覆盖范围； `cumulative_coverage[0]`是输入1之后覆盖的总行数，`cumulative_coverage[1]`是输入1-2之后覆盖的总行数，依此类推。

```py
trials = 100

```

```py
def population_coverage(population, function):
    cumulative_coverage = []
    all_coverage = set()

    for s in population:
        with Coverage() as cov:
            try:
                function(s)
            except:
                pass
        all_coverage |= cov.coverage()
        cumulative_coverage.append(len(all_coverage))

    return all_coverage, cumulative_coverage

```

让我们创建一百个输入来确定覆盖范围如何增加：

```py
def hundred_inputs():
    population = []
    for i in range(trials):
        population.append(fuzzer())
    return population

```

以下是每个输入的覆盖率如何增加：

```py
all_coverage, cumulative_coverage = population_coverage(
    hundred_inputs(), cgi_decode)

```

```py
%matplotlib inline

```

```py
import [matplotlib.pyplot](https://docs.python.org/3/library/matplotlib.pyplot.html) as [plt](https://docs.python.org/3/library/plt.html)

```

```py
plt.plot(cumulative_coverage)
plt.title('Coverage of cgi_decode() with random inputs')
plt.xlabel('# of inputs')
plt.ylabel('lines covered')

```

```py
Text(0,0.5,'lines covered')

```

![](data:image/png;base64,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
)

当然，这只是*一个*运行； 因此，让我们重复多次并绘制平均值。

```py
runs = 100

# Create an array with TRIALS elements, all zero
sum_coverage = [0] * trials

for run in range(runs):
    all_coverage, coverage = population_coverage(hundred_inputs(), cgi_decode)
    assert len(coverage) == trials
    for i in range(trials):
        sum_coverage[i] += coverage[i]

average_coverage = []
for i in range(trials):
    average_coverage.append(sum_coverage[i] / runs)

```

```py
plt.plot(average_coverage)
plt.title('Average coverage of cgi_decode() with random inputs')
plt.xlabel('# of inputs')
plt.ylabel('lines covered')

```

```py
Text(0,0.5,'lines covered')

```

![](data:image/png;base64,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
)

我们看到，平均而言，经过40-60次模糊输入后，我们可以获得完整的覆盖范围。

## 从外部程序获得覆盖

当然，并非全世界都使用Python进行编程。 好消息是，获得覆盖率的问题无处不在，几乎每种编程语言都具有测量覆盖率的功能。 仅作为示例，因此让我们演示如何获得C程序的覆盖率。

我们的C程序（再次）实现`cgi_decode`； 这次作为要从命令行执行的程序：

```py
$ ./cgi_decode 'Hello+World'
Hello World

```

这是C代码，首先是Python字符串。 我们从通常的C开始：

```py
cgi_c_code = """
/* CGI decoding as C program */

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

"""

```

这是`hex_values`的初始化：

```py
cgi_c_code += r"""
int hex_values[256];

void init_hex_values() {
 for (int i = 0; i < sizeof(hex_values) / sizeof(int); i++) {
 hex_values[i] = -1;
 }
 hex_values['0'] = 0; hex_values['1'] = 1; hex_values['2'] = 2; hex_values['3'] = 3;
 hex_values['4'] = 4; hex_values['5'] = 5; hex_values['6'] = 6; hex_values['7'] = 7;
 hex_values['8'] = 8; hex_values['9'] = 9;

 hex_values['a'] = 10; hex_values['b'] = 11; hex_values['c'] = 12; hex_values['d'] = 13;
 hex_values['e'] = 14; hex_values['f'] = 15;

 hex_values['A'] = 10; hex_values['B'] = 11; hex_values['C'] = 12; hex_values['D'] = 13;
 hex_values['E'] = 14; hex_values['F'] = 15;
}
"""

```

这是`cgi_decode()`的实际实现，使用输入源（`s`）和输出目标（`t`）的指针：

```py
cgi_c_code += r"""
int cgi_decode(char *s, char *t) {
 while (*s != '\0') {
 if (*s == '+')
 *t++ = ' ';
 else if (*s == '%') {
 int digit_high = *++s;
 int digit_low = *++s;
 if (hex_values[digit_high] >= 0 && hex_values[digit_low] >= 0) {
 *t++ = hex_values[digit_high] * 16 + hex_values[digit_low];
 }
 else
 return -1;
 }
 else
 *t++ = *s;
 s++;
 }
 *t = '\0';
 return 0;
}
"""

```

最后，这是一个采用第一个参数并使用其调用`cgi_decode`的驱动程序：

```py
cgi_c_code += r"""
int main(int argc, char *argv[]) {
 init_hex_values();

 if (argc >= 2) {
 char *s = argv[1];
 char *t = malloc(strlen(s) + 1); /* output is at most as long as input */
 int ret = cgi_decode(s, t);
 printf("%s\n", t);
 return ret;
 }
 else
 {
 printf("cgi_decode: usage: cgi_decode STRING\n");
 return 1;
 }
}
"""

```

让我们创建C源代码：

```py
with open("cgi_decode.c", "w") as f:
    f.write(cgi_c_code)

```

在这里，我们的C代码突出了语法：

```py
from [fuzzingbook_utils](https://github.com/uds-se/fuzzingbook/tree/master/notebooks/fuzzingbook_utils) import print_file

```

```py
print_file("cgi_decode.c")

```

```py
/* CGI decoding as C program */

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

int hex_values[256];

void init_hex_values() {
    for (int i = 0; i < sizeof(hex_values) / sizeof(int); i++) {
        hex_values[i] = -1;
    }
    hex_values['0'] = 0; hex_values['1'] = 1; hex_values['2'] = 2; hex_values['3'] = 3;
    hex_values['4'] = 4; hex_values['5'] = 5; hex_values['6'] = 6; hex_values['7'] = 7;
    hex_values['8'] = 8; hex_values['9'] = 9;

    hex_values['a'] = 10; hex_values['b'] = 11; hex_values['c'] = 12; hex_values['d'] = 13;
    hex_values['e'] = 14; hex_values['f'] = 15;

    hex_values['A'] = 10; hex_values['B'] = 11; hex_values['C'] = 12; hex_values['D'] = 13;
    hex_values['E'] = 14; hex_values['F'] = 15;
}

int cgi_decode(char *s, char *t) {
    while (*s != '\0') {
        if (*s == '+')
            *t++ = '  ';
        else if (*s == '%') {
            int digit_high = *++s;
            int digit_low = *++s;
            if (hex_values[digit_high] >= 0 && hex_values[digit_low] >= 0) {
                *t++ = hex_values[digit_high] * 16 + hex_values[digit_low];
            }
            else
                return -1;
        }
        else
            *t++ = *s;
        s++;
    }
    *t = '\0';
    return 0;
}

int main(int argc, char *argv[]) {
    init_hex_values();

    if (argc >= 2) {
        char *s = argv[1];
        char *t = malloc(strlen(s) + 1); /* output is at most as long as input */
        int ret = cgi_decode(s, t);
        printf("%s\n", t);
        return ret;
    }
    else
    {
        printf("cgi_decode: usage: cgi_decode STRING\n");
        return 1;
    }
}

```

现在，我们可以将C代码编译为可执行文件。 `--coverage`选项指示C编译器对代码进行检测，以便在运行时收集覆盖率信息。 （确切的选项因编译器而异。）

```py
!cc --coverage -o cgi_decode cgi_decode.c

```

当我们现在执行程序时，覆盖率信息将自动收集并存储在辅助文件中：

```py
!./cgi_decode 'Send+mail+to+me%40fuzzingbook.org'

```

```py
Send mail to me@fuzzingbook.org

```

覆盖范围信息由`gcov`程序收集。 对于给定的每个源文件，它将生成一个具有覆盖率信息的新`.gcov`文件。

```py
!gcov cgi_decode.c

```

```py
File 'cgi_decode.c'
Lines executed:91.89% of 37
cgi_decode.c:creating 'cgi_decode.c.gcov'

```

在`.gcov`文件中，每行都以被调用的次数为前缀（`-`代表不可执行的行，`#####`代表零）以及行号。 例如，我们可以看一下`cgi_decode()`，看到唯一尚未执行的代码就是用于非法输入的`return -1`。

```py
lines = open('cgi_decode.c.gcov').readlines()
for i in range(30, 50):
    print(lines[i], end='')

```

```py
        -:   26:int cgi_decode(char *s, char *t) {
       64:   27:    while (*s != '\0') {
       31:   28:        if (*s == '+')
        3:   29:            *t++ = ' ';
       28:   30:        else if (*s == '%') {
        1:   31:            int digit_high = *++s;
        1:   32:            int digit_low = *++s;
        2:   33:            if (hex_values[digit_high] >= 0 && hex_values[digit_low] >= 0) {
        1:   34:                *t++ = hex_values[digit_high] * 16 + hex_values[digit_low];
        1:   35:            }
        -:   36:            else
    #####:   37:                return -1;
        1:   38:        }
        -:   39:        else
       27:   40:            *t++ = *s;
       31:   41:        s++;
        -:   42:    }
        1:   43:    *t = '\0';
        1:   44:    return 0;
        1:   45:}

```

让我们阅读此文件以获得覆盖范围集：

```py
def read_gcov_coverage(c_file):
    gcov_file = c_file + ".gcov"
    coverage = set()
    with open(gcov_file) as file:
        for line in file.readlines():
            elems = line.split(':')
            covered = elems[0].strip()
            line_number = int(elems[1].strip())
            if covered.startswith('-') or covered.startswith('#'):
                continue
            coverage.add((c_file, line_number))
    return coverage

```

```py
coverage = read_gcov_coverage('cgi_decode.c')

```

```py
list(coverage)[:5]

```

```py
[('cgi_decode.c', 24),
 ('cgi_decode.c', 32),
 ('cgi_decode.c', 20),
 ('cgi_decode.c', 43),
 ('cgi_decode.c', 53)]

```

有了这个设置，我们现在可以执行与Python程序相同的coverage计算。

## 使用基本模糊查找错误

只要有足够的时间，无论编程语言是什么，我们实际上都可以覆盖`cgi_decode()`中的每一行。 但是，这并不意味着它们将没有错误。 由于我们不检查`cgi_decode()`的结果，因此该函数可以返回任何值，而无需我们检查或注意。 为了捕获此类错误，我们将必须设置一个*结果检查器*（通常称为 *oracle* ）来验证测试结果。 在我们的案例中，我们可以比较`cgi_decode()`的C和Python实现，并查看两者是否产生相同的结果。

但是，模糊测试最擅长的是找到*内部错误*，即使不检查结果也可以检测到。 实际上，如果在`cgi_decode()`上运行我们的`fuzzer()`，则可以迅速发现这样的错误，如以下代码所示：

```py
from [ExpectError](ExpectError.html) import ExpectError

```

```py
with ExpectError():
    for i in range(trials):
        try:
            s = fuzzer()
            cgi_decode(s)
        except ValueError:
            pass

```

```py
Traceback (most recent call last):
  File "<ipython-input-54-086d4892c70e>", line 5, in <module>
    cgi_decode(s)
  File "<ipython-input-1-4d0fb90b50b4>", line 22, in cgi_decode
    digit_high, digit_low = s[i + 1], s[i + 2]
IndexError: string index out of range (expected)

```

因此，有可能导致`cgi_decode()`崩溃。 这是为什么？ 让我们看一下它的输入：

```py
s

```

```py
'82 202*&<1&($34\'"/\'.<5/!8"\'5:!4))%;'

```

问题在字符串的末尾。 在`'%'`字符之后，我们的实现将始终尝试访问另外两个（十六进制）字符，但是如果这些字符不存在，我们将获得`IndexError`异常。

这个问题也存在于我们的C变体中，该变体继承了原始实现[[Pezzè*等*，2008\.](http://ix.cs.uoregon.edu/~michal/book/) ]：

```py
int digit_high = *++s;
int digit_low = *++s;

```

这里，`s`是指向要读取的字符的指针； `++`将其增加一个字符。 在C实现中，问题实际上要严重得多。 如果`'%'`字符位于字符串的末尾，则上面的代码将首先读取终止字符（C字符串中的`'\0'`），然后读取随后的字符，该字符可以是字符串之后的任何内存内容，因此 可能会导致程序无法控制地失败。 好消息是`'\0'`不是有效的十六进制字符，因此C版本将“仅”读取字符串末尾的一个字符。

有趣的是，我们之前设计的任何手动测试都不会触发此错误。 实际上，无论是陈述，分支机构覆盖率，还是文献中通常讨论的覆盖率标准，都找不到它。 但是，简单的模糊运行可以通过几次运行来识别错误–如果适当的运行时检查已经找到*，则会发现此类溢出。 这肯定需要更多的模糊测试！*

## 经验教训

*   覆盖率指标是一种简单且完全自动化的方法，用于估算在测试运行期间实际执行了多少程序功能。
*   存在许多覆盖率指标，最重要的是语句覆盖率和分支覆盖率。
*   在Python中，执行期间访问程序状态非常容易，包括当前执行的代码。

归根结底，让我们清理一下：

```py
import [os](https://docs.python.org/3/library/os.html)
import [glob](https://docs.python.org/3/library/glob.html)

```

```py
for file in glob.glob("cgi_decode") + glob.glob("cgi_decode.*"):
    os.remove(file)

```

## 后续步骤

覆盖率不仅是*衡量*测试有效性的工具，还是*指导*测试朝着特定目标（尤其是未发现的代码）的生成的强大工具。 我们使用覆盖范围

*   [指导现有输入的*突变*更好地覆盖有关突变模糊](MutationFuzzer.html)一章的内容

## 背景

覆盖率是系统软件测试中的核心概念。 有关讨论，请参见[测试简介](Intro_Testing.html)中的书。

## 练习

### 练习1：修复cgi_decode

创建一个适当的测试来重现上面讨论的`IndexError`。 修复`cgi_decode()`以防止该错误。 显示您的测试（以及其他`fuzzer()`运行）不再暴露该错误。 对C变体执行相同的操作。

[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/master?filepath=docs/notebooks/Coverage.ipynb#Exercises) to work on the exercises and see solutions.

### 练习2：分支覆盖率

除了语句覆盖率之外，*分支覆盖率*是确定测试质量的最常用标准之一。 简而言之，分支覆盖率衡量了在代码中做出了多少个不同的*控制决策*。 在声明中

```py
if CONDITION:
    do_a()
else:
    do_b()

```

例如，必须涵盖`CONDITION`为真（分支为`do_a()`）和`CONDITION`为假（分支为`do_b()`）的情况。 这适用于所有带有条件（`if`，`while`等）的控制语句。

分支机构的覆盖范围与语句的覆盖范围有何不同？ 在上面的示例中，实际上没有区别。 但是，在此代码中有：

```py
if CONDITION:
    do_a()
something_else()

```

使用语句覆盖率，`CONDITION`为真的单个测试用例就足以覆盖对`do_a()`的调用。 但是，使用分支覆盖，我们还必须创建一个测试用例，其中未调用*的`do_a()`。*

使用我们的`Coverage`基础结构，我们可以通过考虑执行的后续行对*来模拟分支覆盖。 `trace()`方法为我们提供了一个接一个执行的行的列表：*

```py
with Coverage() as cov:
    cgi_decode("a+b")
trace = cov.trace()
trace[:5]

```

```py
[('cgi_decode', 9),
 ('cgi_decode', 10),
 ('cgi_decode', 11),
 ('cgi_decode', 12),
 ('cgi_decode', 15)]

```

#### 第1部分：计算分支覆盖范围

定义一个函数`branch_coverage()`，该函数接受跟踪并返回跟踪中的一对后续行对–在上面的示例中，这将是

```py
set(
(('cgi_decode', 9), ('cgi_decode', 10)),
(('cgi_decode', 10), ('cgi_decode', 11)),
# more_pairs
)

```

对于高级Python程序员的奖励：将`BranchCoverage`定义为`Coverage`的子类，并使`branch_coverage()`像`BranchCoverage`的`coverage()`方法一样。

[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/master?filepath=docs/notebooks/Coverage.ipynb#Exercises) to work on the exercises and see solutions.

#### 第2部分：比较语句覆盖率和分支覆盖率

使用`branch_coverage()`使用分支覆盖而不是语句覆盖来重复本章中的实验。 手动编写的测试用例是否覆盖所有分支？

[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/master?filepath=docs/notebooks/Coverage.ipynb#Exercises) to work on the exercises and see solutions.

#### 第3部分：平均覆盖率

再次，用分支覆盖重复上述实验。 `fuzzer()`是否覆盖所有分支，如果是，则平均要进行多少次测试？

[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/master?filepath=docs/notebooks/Coverage.ipynb#Exercises) to work on the exercises and see solutions.